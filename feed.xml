<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-12-25T14:20:15+01:00</updated><id>/feed.xml</id><title type="html">Mannberg on Swift</title><entry><title type="html">Avoid mocking by swapping method implementations</title><link href="/2018/12/19/mocking.html" rel="alternate" type="text/html" title="Avoid mocking by swapping method implementations" /><published>2018-12-19T21:00:00+01:00</published><updated>2018-12-19T21:00:00+01:00</updated><id>/2018/12/19/mocking</id><content type="html" xml:base="/2018/12/19/mocking.html">&lt;h6 id=&quot;syntax-highlighting-powered-by-splash&quot;&gt;Syntax highlighting powered by &lt;a href=&quot;https://github.com/JohnSundell/Splash&quot;&gt;Splash&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;Often when we want to test code that depends on external resources such as a backend or a local database, we need to mock those dependencies. Mocking usually consists of defining a protocol which our other objects depend on rather than depending on a concrete implementation, as well as creating at least two classes/structs that implement that protocol - one that‚Äôs used in our app, and at least one mock version used for testing.&lt;/p&gt;

&lt;p&gt;This choice of path usually ends up in writing lots of boilerplate code, in addition to all the extra code we‚Äôre already writing for our tests. Few people would probably argue against testing as a good thing, but in the harsh reality of tight deadlines it‚Äôs no secret that test code is constantly in harm‚Äôs way. So, anything we can do to make writing tests less of a hassle, we should.&lt;/p&gt;

&lt;p&gt;In this article we‚Äôre going to a explore a less object-oriented approach, in which we‚Äôll mock methods rather than entire objects.&lt;/p&gt;

&lt;h3 id=&quot;fetching-movies&quot;&gt;Fetching movies&lt;/h3&gt;

&lt;p&gt;Let‚Äôs say we have a simple app that fetches a bunch of movies from an api and presents them in a &lt;code class=&quot;highlighter-rouge&quot;&gt;MovieListViewController&lt;/code&gt;. To do this, we need some sort of &lt;code class=&quot;highlighter-rouge&quot;&gt;APIService&lt;/code&gt; that makes network requests to fetch that data.&lt;/p&gt;

&lt;p&gt;Since we want to write tests for objects depending on this class, we want to be able to mock it, so we start by defining a protocol as follows&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;protocol&lt;/span&gt; NetworkFetching {
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fetchMovies(result: (&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we create the concrete implementation that will be used used in our app‚Ä¶&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; APIService: &lt;span class=&quot;type&quot;&gt;NetworkFetching&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fetchMovies(result: (&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) {
        &lt;span class=&quot;comment&quot;&gt;//Perform&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;fetch&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;movies&lt;/span&gt;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‚Ä¶ and then our mocked class.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; MockAPIService: &lt;span class=&quot;type&quot;&gt;NetworkFetching&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fetchMovies(result: (&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) {
        &lt;span class=&quot;comment&quot;&gt;//Return&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;hard-coded&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;result&lt;/span&gt;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We‚Äôve designed our app so that &lt;code class=&quot;highlighter-rouge&quot;&gt;MovieListViewController&lt;/code&gt; has a &lt;code class=&quot;highlighter-rouge&quot;&gt;MovieListViewModel&lt;/code&gt;, which in turn has a reference to an &lt;code class=&quot;highlighter-rouge&quot;&gt;APIService&lt;/code&gt; instance implementing the &lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkFetching&lt;/code&gt; protocol. The view model also has a &lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt; property which our view controller binds to in order to update it‚Äôs views. We might, for example, want to show/hide a loading indicator as we‚Äôre waiting for/presenting data, and show error messages if the request should fail.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; MovieListViewModel {
    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lazy&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; apiService = factory.&lt;span class=&quot;call&quot;&gt;makeAPIService&lt;/span&gt;()
    ...
    
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fetchMovies() {
        state = .&lt;span class=&quot;dotAccess&quot;&gt;loading&lt;/span&gt;
        apiService.&lt;span class=&quot;call&quot;&gt;fetchMovies&lt;/span&gt; { result &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; result {
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;dotAccess&quot;&gt;success&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; movies):
                &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;movies&lt;/span&gt; = movies
                state = .&lt;span class=&quot;dotAccess&quot;&gt;doneLoading&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;dotAccess&quot;&gt;failure&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; error):
                state = .&lt;span class=&quot;dotAccess&quot;&gt;failedLoading&lt;/span&gt;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now decide we want a unit test that ensures our view model always correctly updates it‚Äôs state property to &lt;code class=&quot;highlighter-rouge&quot;&gt;.doneLoading&lt;/code&gt; when we get a successful reponse from our backend. In other words, we want to test our view model‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;fetchMovies&lt;/code&gt; method but mock out the actual network request in our &lt;code class=&quot;highlighter-rouge&quot;&gt;APIService&lt;/code&gt;. We also want to make sure our view model‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;movies&lt;/code&gt; property is updated as expected. So we‚Äôll implement the mocked method to just return hard-coded data&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; MockAPIService: &lt;span class=&quot;type&quot;&gt;NetworkFetching&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fetchMovies(handler: (&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; movies = [
            &lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Forrest&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Gump&quot;&lt;/span&gt;, rating: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;),
        ]

        &lt;span class=&quot;call&quot;&gt;handler&lt;/span&gt;(.&lt;span class=&quot;dotAccess&quot;&gt;success&lt;/span&gt;(movies))   
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we‚Äôll write our test&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; testFetchMoviesSuccessShouldSetStateToDoneLoading {
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; viewModel = &lt;span class=&quot;type&quot;&gt;MovieListViewModel&lt;/span&gt;(factory: &lt;span class=&quot;type&quot;&gt;MockFactory&lt;/span&gt;())

    viewModel.&lt;span class=&quot;call&quot;&gt;fetchMovies&lt;/span&gt;()
    &lt;span class=&quot;type&quot;&gt;XCTAssertTrue&lt;/span&gt;(viewModel.&lt;span class=&quot;property&quot;&gt;state&lt;/span&gt; == .&lt;span class=&quot;dotAccess&quot;&gt;doneLoading&lt;/span&gt;)
    &lt;span class=&quot;type&quot;&gt;XCTAssertTrue&lt;/span&gt;(viewModel.&lt;span class=&quot;property&quot;&gt;movies&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;count&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing to note is that we‚Äôre using a Factory to set up our objects and inject that Factory rather than making our objects responsible for injecting and creating other objects. This pattern is really great for isolating dependencies, but by using this approach together with mocking, we probably also want to create a MockFactory that implements a &lt;code class=&quot;highlighter-rouge&quot;&gt;Factory&lt;/code&gt; protocol. In other words, even more boilerplate code!&lt;/p&gt;

&lt;h3 id=&quot;just-in-time-mocking&quot;&gt;‚ÄúJust-in-time‚Äù mocking&lt;/h3&gt;

&lt;p&gt;Perhaps it‚Äôs time we stop and think about what part of all that extra code that was actually needed for us in order to test our code. The &lt;code class=&quot;highlighter-rouge&quot;&gt;MockAPIService&lt;/code&gt; class has no real value in itself rather than being a wrapper for the mocked &lt;code class=&quot;highlighter-rouge&quot;&gt;fetchMovies&lt;/code&gt; method whose output - a result type containing a hard-coded list of movies - we were interested in. And although the protocol-oriented nature of Swift is really great, it‚Äôs not unusual that we end up with protocols that are there just for the sake of mocking.&lt;/p&gt;

&lt;p&gt;Perhaps we could try a more functional approach! So let‚Äôs redo this a bit. Firstly, we‚Äôll scrap our &lt;code class=&quot;highlighter-rouge&quot;&gt;MockAPIService&lt;/code&gt; as well as the &lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkFetching&lt;/code&gt; protocol. Also, away with the unnecessary &lt;code class=&quot;highlighter-rouge&quot;&gt;MockFactory&lt;/code&gt; implementation.&lt;/p&gt;

&lt;p&gt;We‚Äôll then rewrite our &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiService&lt;/code&gt; from this‚Ä¶&lt;/p&gt;
&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; APIService: &lt;span class=&quot;type&quot;&gt;NetworkFetching&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fetchMovies(result: (&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‚Ä¶ to this&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; APIService {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fetchMovies: ((&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt; = { handler &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our &lt;code class=&quot;highlighter-rouge&quot;&gt;fetchMovies&lt;/code&gt; method still has the exact same function signature as it did before‚Ä¶&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;((&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‚Ä¶ but we redefined it using closure syntax and stored it in a variable, the latter being key since mutability is just what we‚Äôre after here.&lt;/p&gt;

&lt;p&gt;Now that we‚Äôve scrapped 2 protocols and 2 mocked classes, we should try to rewrite our unit test.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; testFetchMoviesSuccessShouldSetStateToDoneLoading {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; viewModel = &lt;span class=&quot;type&quot;&gt;MovieListViewModel&lt;/span&gt;(factory: &lt;span class=&quot;type&quot;&gt;Factory&lt;/span&gt;())

    viewModel.&lt;span class=&quot;property&quot;&gt;apiService&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;fetchMovies&lt;/span&gt; = { handler &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; movies = [
            &lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Forrest&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Gump&quot;&lt;/span&gt;, rating: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;),
        ]

        &lt;span class=&quot;call&quot;&gt;handler&lt;/span&gt;(.&lt;span class=&quot;dotAccess&quot;&gt;success&lt;/span&gt;(movies))   
    }

    viewModel.&lt;span class=&quot;call&quot;&gt;fetchMovies&lt;/span&gt;()
    &lt;span class=&quot;type&quot;&gt;XCTAssertTrue&lt;/span&gt;(viewModel.&lt;span class=&quot;property&quot;&gt;state&lt;/span&gt; == .&lt;span class=&quot;dotAccess&quot;&gt;doneLoading&lt;/span&gt;)
    &lt;span class=&quot;type&quot;&gt;XCTAssertTrue&lt;/span&gt;(viewModel.&lt;span class=&quot;property&quot;&gt;movies&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;count&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that by just swapping a method implementation, we could easily mock the state we needed to test our code. Since we removed the mock classes and also the protocols that were really just there for testing purposes, all our test-specific code is right now contained in our test target, right where it belongs!&lt;/p&gt;

&lt;p&gt;One great thing about this approach is it‚Äôs flexibility. For example, we might want to mock several different types of network responses to test how our depending classes behave. This is hassle-free and involves no creation of additional mock objects&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; testFetchMoviesErrorShouldSetStateToFailedLoading {
    ...
    viewModel.&lt;span class=&quot;property&quot;&gt;apiService&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;fetchMovies&lt;/span&gt; = { handler &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
        handler(.&lt;span class=&quot;dotAccess&quot;&gt;failure&lt;/span&gt;(.&lt;span class=&quot;dotAccess&quot;&gt;timeout&lt;/span&gt;))   
    }

    viewModel.&lt;span class=&quot;call&quot;&gt;fetchMovies&lt;/span&gt;()
    &lt;span class=&quot;type&quot;&gt;XCTAssertTrue&lt;/span&gt;(viewModel.&lt;span class=&quot;property&quot;&gt;state&lt;/span&gt; == .&lt;span class=&quot;dotAccess&quot;&gt;failedLoading&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;drawbacks&quot;&gt;Drawbacks&lt;/h3&gt;

&lt;p&gt;Ok, so here come the boring, mildly shocking, news: This solution is &lt;em&gt;not&lt;/em&gt; perfect üò≤. Let‚Äôs look at some of the drawbacks.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Named parameters don‚Äôt work with closures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Named parameters is, according to me, one of the things that makes Swift really stand out from many other languages. Unfortunately, defining our methods as mutable closures, we have to give up on this great feature&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;//this&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; movie: &lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;, asFavorite favorite: &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) {...}

&lt;span class=&quot;call&quot;&gt;set&lt;/span&gt;(someMovie, asFavorite: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)

&lt;span class=&quot;comment&quot;&gt;//becomes&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;this&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; set: (&lt;span class=&quot;type&quot;&gt;Movie&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) = { movie, favorite &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ...}

&lt;span class=&quot;call&quot;&gt;set&lt;/span&gt;(someMovie, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Mutability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It might seem as a bit of an anti-pattern to have all this mutable state floating around in our application. Actually, as far as methods are concerned, the risk of an object accidentally replacing a method implementation with another one is probably not that big.&lt;/p&gt;

&lt;p&gt;Making stored properties mutable for the sake of testing flexibility, however, seems far riskier and is probably something we should avoid doing. Using computed properties or immutable stored properties as much as possible should be the way forward here.&lt;/p&gt;

&lt;p&gt;Thanks a bunch for reading! Please feel free to reach out on &lt;a href=&quot;https://twitter.com/andersmannberg&quot;&gt;Twitter&lt;/a&gt; and share your thoughts on this and other Swifty topics!&lt;/p&gt;</content><author><name></name></author><summary type="html">Syntax highlighting powered by Splash</summary></entry><entry><title type="html">Testing your UI using method swizzling</title><link href="/2018/10/07/testing-your-ui-using-method-swizzling.html" rel="alternate" type="text/html" title="Testing your UI using method swizzling" /><published>2018-10-07T22:32:38+02:00</published><updated>2018-10-07T22:32:38+02:00</updated><id>/2018/10/07/testing-your-ui-using-method-swizzling</id><content type="html" xml:base="/2018/10/07/testing-your-ui-using-method-swizzling.html">&lt;h6 id=&quot;syntax-highlighting-powered-by-splash&quot;&gt;Syntax highlighting powered by &lt;a href=&quot;https://github.com/JohnSundell/Splash&quot;&gt;Splash&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;Bugs come in many forms, and one of the classics is when our app‚Äôs UI is messed up by rendering data that is either much larger or much smaller than we expected during development. For example, if you‚Äôve ever done work on an app, chances are good you‚Äôve come across a label which overlaps other elements when it‚Äôs text gets too long, or clips the text in some unexpected, unwanted way. In this post, I‚Äôm going to show a neat trick on how to easily test the entire UI for this without adding lots of code, using a technique called method swizzling.&lt;/p&gt;

&lt;h3 id=&quot;method-swizzling&quot;&gt;Method swizzling&lt;/h3&gt;

&lt;p&gt;In short, swizzling is a technique available through the Objective C runtime library, which allows you to make a swap so that the selector, or name, of method m1 points to the implementation of another method m2, and vice versa. I won‚Äôt go into detail about swizzling or the Objective C runtime in general in this article, but I really recommend reading Apple‚Äôs documentation on the matter, to get a feeling for the extremely dynamic nature of what goes on under the hood when you develop using iOS and macOS frameworks. More of that stuff in a future post!&lt;/p&gt;

&lt;p&gt;To give an example of how swizzling could be used: With a few lines of code we could replace the &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad()&lt;/code&gt; implementation of every single instance of UIViewController, so that every time it is called on a UIViewController or any of it‚Äôs subclasses, our customized version that we might wanna call &lt;code class=&quot;highlighter-rouge&quot;&gt;swizzledViewDidLoad()&lt;/code&gt; would be executed instead. Note that this is different from overriding a method in a subclass, since we by swizzling can replace the implementations of the actual base classes in Apple‚Äôs closed source frameworks such as UIKit and Foundation. Cool stuff for sure!&lt;/p&gt;

&lt;h3 id=&quot;testing-labels&quot;&gt;Testing labels&lt;/h3&gt;

&lt;p&gt;To help us debug our UI in order to detect nasty UILabel bugs, we are going to replace the method that is called when setting the text property of a UILabel&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;label.&lt;span class=&quot;property&quot;&gt;text&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;This&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;swizzled&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;away!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for doing this is that we want to define a really long text with great potential to mess up the UI, and we want to be able to make every single label in the app show this text simultaneously, whether a base class or a subclass instance. In this way we can easily see how long strings are handled as our UI evolves. What‚Äôs nice about using swizzling in this case, is that we can accomplish what we want without having to make any changes to the call sites where our labels are used. This of course saves us time and prevents us from polluting our code with debug-specific stuff.&lt;/p&gt;

&lt;p&gt;Basically, we‚Äôre just going to use 2 methods from the Objective C Runtime library:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;//Gets&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;reference&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;cls&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; class_getInstanceMethod(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; cls: &lt;span class=&quot;type&quot;&gt;AnyClass&lt;/span&gt;?,
                           &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;Selector&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Method&lt;/span&gt;?

&lt;span class=&quot;comment&quot;&gt;//swaps&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;m1&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;m2,&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;calling&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;m1&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;executes&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;m2,&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;vice&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;versa&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; method_exchangeImplementations(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; m1: &lt;span class=&quot;type&quot;&gt;Method&lt;/span&gt;,
                                  &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; m2: &lt;span class=&quot;type&quot;&gt;Method&lt;/span&gt;)                        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we might want to do a whole lot of swizzling in our project, we‚Äôll wrap these methods in a generic &lt;code class=&quot;highlighter-rouge&quot;&gt;Swizzler&lt;/code&gt; struct to have a bit more pleasant API to work with&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Swizzler&amp;lt;T: &lt;span class=&quot;type&quot;&gt;NSObject&lt;/span&gt;&amp;gt; {
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; swizzle(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; originalSelector: &lt;span class=&quot;type&quot;&gt;Selector&lt;/span&gt;,
                        &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; swizzledSelector: &lt;span class=&quot;type&quot;&gt;Selector&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; `&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;`: &lt;span class=&quot;type&quot;&gt;AnyClass&lt;/span&gt;! = &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;

        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; originalMethod = class_getInstanceMethod(`&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;`, originalSelector),
            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; swizzledMethod = class_getInstanceMethod(`&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;`, swizzledSelector) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;
        }

        &lt;span class=&quot;call&quot;&gt;method_exchangeImplementations&lt;/span&gt;(originalMethod, swizzledMethod)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We‚Äôll then extend UILabel with a method called &lt;code class=&quot;highlighter-rouge&quot;&gt;setReallyLongText&lt;/code&gt;, which will replace the &lt;code class=&quot;highlighter-rouge&quot;&gt;label.text&lt;/code&gt; implementation. We‚Äôll also add a static func which performs the actual implementation swap via our Swizzler struct&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;UILabel&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;@objc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; setReallyLongText(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; text: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; replacementText = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;Bacon&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;ipsum&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;dolor&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;amet&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;turducken&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;ground&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;round&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;cow&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;pastrami&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;prosciutto&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;cupim&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;picanha,&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;sirloin&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;ham&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;bresaola&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;leberkas&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;corned&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;beef&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;tip.&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Spare&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;ribs&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;pork&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;chop&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;ribs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;pork&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;tenderloin&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;sausage&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;tongue&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;biltong.&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;setReallyLongText&lt;/span&gt;(replacementText)
    }

    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; swizzleSetReallyLongText() {
        &lt;span class=&quot;type&quot;&gt;Swizzler&lt;/span&gt;&amp;lt;UILabel&amp;gt;.&lt;span class=&quot;call&quot;&gt;swizzle&lt;/span&gt;(#selector(setter: text), &lt;span class=&quot;keyword&quot;&gt;#selector&lt;/span&gt;(&lt;span class=&quot;call&quot;&gt;setReallyLongText&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt;:)))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then call &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel.swizzleSetReallyLongText()&lt;/code&gt; somewhere early in our app‚Äôs lifecycle, and by doing so, all code in the app using the &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; setter will instead call our &lt;code class=&quot;highlighter-rouge&quot;&gt;setReallyLongText&lt;/code&gt; method with the given string passed as an argument.&lt;/p&gt;

&lt;p&gt;Note that our method seems to call itself with the replacementText we‚Äôve defined, which is actually not as recursive as it might come across&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;@objc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; setReallyLongText(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; text: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) {
    ...
    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;setReallyLongText&lt;/span&gt;(replacementText)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that we swapped names for UILabel‚Äôs text setter, and our own method. So when &lt;code class=&quot;highlighter-rouge&quot;&gt;label.text&lt;/code&gt; is invoked in our code, the implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;setReallyLongText&lt;/code&gt; is executed, and when &lt;code class=&quot;highlighter-rouge&quot;&gt;setReallyLongText&lt;/code&gt; is invoked in our code, the implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;label.text&lt;/code&gt; is executed. So the above method hijacks the text setter method, replaces the string passed to it, and then passes this new string along to the original setter.&lt;/p&gt;

&lt;h3 id=&quot;with-great-power-comes-great-responsibility&quot;&gt;With great power comes great responsibility&lt;/h3&gt;

&lt;p&gt;Although method swizzling might seem bordering on black magic, using it in your code should not be a problem as far as getting your app to App Store is concerned. However, it‚Äôs still something that could seriously mess up your code if you don‚Äôt tread with caution. Since we have no idea what the actual implementation of methods in UIKit or Foundation look like, there‚Äôs a risk of swizzling away some very important functionality which will cause trouble down the road. It‚Äôs likely a good idea to call the original implementation in your hijacked method unless you have a very good reason not too. And unless you really know what you‚Äôre doing, it‚Äôs probably a good idea not use this stuff in production.&lt;/p&gt;

&lt;p&gt;When having code that is debug/test specific, it‚Äôs good practice to create a separate target in Xcode. By doing this you can add custom flags to your target which will activate test-specific functionality when building that target only. In this way you don‚Äôt have to manually activate/deactivate debug features in your code whenever you want to test things, which is both tedious and risky, should you ever forget to change something back before shipping your app.&lt;/p&gt;

&lt;p&gt;In this case, I added a specific Test target to my project and added a TEST flag under Build Settings -&amp;gt; Swift Compiler - Custom Flags -&amp;gt; Active Compilation Conditions. I then put the following code in my AppDelegate‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;didFinishLaunching...&lt;/code&gt; method to make sure swizzling is left out whenever we‚Äôre not testing&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;preprocessing&quot;&gt;#if&lt;/span&gt; &lt;span class=&quot;preprocessing&quot;&gt;TEST&lt;/span&gt;
&lt;span class=&quot;type&quot;&gt;UILabel&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;swizzleSetReallyLongText&lt;/span&gt;()
&lt;span class=&quot;preprocessing&quot;&gt;#endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;other-uses-of-swizzling&quot;&gt;Other uses of swizzling&lt;/h3&gt;

&lt;p&gt;Hopefully this post can serve as an inspiration for coming up with other ways to use swizzling for debugging purposes. One use case could be if you wanted to log something whenever a certain method is invoked. For example, you might want to know whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad()&lt;/code&gt; is called in your app‚Äôs different view controllers. Instead of adding logging code to every single view controller class, you could easily hijack &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad()&lt;/code&gt; on UIViewController and add your logging code there.&lt;/p&gt;

&lt;p&gt;This might look something like this&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;@objc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; logViewDidLoad() {
        &lt;span class=&quot;type&quot;&gt;Logger&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;viewDidLoad&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;executed&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;for&lt;/span&gt; \(&lt;span class=&quot;call&quot;&gt;type&lt;/span&gt;(of: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;))&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;)
        &lt;span class=&quot;call&quot;&gt;logViewDidLoad&lt;/span&gt;()
    }

    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; swizzleLogViewDidLoad() {
        &lt;span class=&quot;type&quot;&gt;Swizzler&lt;/span&gt;&amp;lt;UIViewController&amp;gt;.&lt;span class=&quot;call&quot;&gt;swizzle&lt;/span&gt;(#selector(viewDidLoad), &lt;span class=&quot;keyword&quot;&gt;#selector&lt;/span&gt;(logViewDidLoad))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really hope you enjoyed this post, and I would love to hear from you on Twitter. Thank you so much for reading!&lt;/p&gt;</content><author><name></name></author><summary type="html">Syntax highlighting powered by Splash</summary></entry><entry><title type="html">Failable initializers and self-validating models</title><link href="/2018/08/20/failable-initializers-and-self-validating-models.html" rel="alternate" type="text/html" title="Failable initializers and self-validating models" /><published>2018-08-20T22:32:38+02:00</published><updated>2018-08-20T22:32:38+02:00</updated><id>/2018/08/20/failable-initializers-and-self-validating-models</id><content type="html" xml:base="/2018/08/20/failable-initializers-and-self-validating-models.html">&lt;h6 id=&quot;syntax-highlighting-powered-by-splash&quot;&gt;Syntax highlighting powered by &lt;a href=&quot;https://github.com/JohnSundell/Splash&quot;&gt;Splash&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;Often when coding, we need to deal with validating user input. A typical example would be a registration form, where you‚Äôll often have validation logic for email addresses, phone numbers, credit cards etc. This post is going to look at different examples of structuring this kind of code. Let‚Äôs use a really simple example, where a user has to fill in mandatory values for name and email address, where the latter will be validated locally. After completing the form, we‚Äôll create a &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; object. We‚Äôre not going to bother at all with the actual validation logic here, but rather on creating the interface for it. We‚Äôll start by writing code which can be improved and then refactor this as we go along.&lt;/p&gt;

&lt;p&gt;First, well create a &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; User {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; emailAddress: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
}

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: &lt;span class=&quot;string&quot;&gt;&quot;dohn.joe@somecompany.com&quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we pass user data on to our backend, we‚Äôll want some local validation logic for the email address. One possible place to put this code could be in some sort of dedicated validator struct:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; EmailValidator {
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; isValidEmailAddress(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; string: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; {
        ...
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; valueOfValidation
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could now use our validator like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; addressToValidate = &lt;span class=&quot;string&quot;&gt;&quot;dohn.joe@somecompany.com&quot;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;EmailValidator&lt;/span&gt;().&lt;span class=&quot;call&quot;&gt;isValidEmailAddress&lt;/span&gt;(addressToValidate) {
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: addressToValidate)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Personally, I‚Äôm not very fond of objects named things like &lt;code class=&quot;highlighter-rouge&quot;&gt;Validator&lt;/code&gt;. Even though it‚Äôs quite obvious what an &lt;code class=&quot;highlighter-rouge&quot;&gt;EmailValidator&lt;/code&gt; does, I think this type of ‚Äúextremely‚Äù object-oriented naming convention (every verb becomes a noun) often leads to having lots of classes that are hard to reason about and know how to use. But this is something I will elaborate on in a future post. Naming preferences aside, a problem with &lt;code class=&quot;highlighter-rouge&quot;&gt;EmailValidator&lt;/code&gt; in this case is that it‚Äôs usage is optional. By mistake we could bypass email validation and still create a user object, leaving room for potential errors:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A possible (but not very elegant) way to solve this could be injecting the validator into our &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; struct. We could also add what is called a failable initalizer to &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;, which is an init method that returns either an object or a nil value, depending on whatever conditions we set. In this way, we would always have to pass a valid email address to get a instance rather than getting nil:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; User {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; emailAddress: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;

    &lt;span class=&quot;comment&quot;&gt;//Failable&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;initializer,&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;notice&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;question&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;mark&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;?(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, emailAddress: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, validator: &lt;span class=&quot;type&quot;&gt;EmailValidator&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; validator.&lt;span class=&quot;call&quot;&gt;isValidEmailAddress&lt;/span&gt;(address) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;
        }

        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;name&lt;/span&gt; = name
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;emailAddress&lt;/span&gt; = emailAddress
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would allow us to create users like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: &lt;span class=&quot;string&quot;&gt;&quot;dohn.joe@somecompany.com&quot;&lt;/span&gt;, validator: &lt;span class=&quot;type&quot;&gt;EmailValidator&lt;/span&gt;())
{
    &lt;span class=&quot;comment&quot;&gt;//We&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;have&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;user!&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, this is not pretty. What‚Äôs good is that we now can‚Äôt create a user object without a valid email address, but what‚Äôs bad is that the data model is deviating from the real world (however abstract) object it is modelling. A user has a name and an email address, but it surely doesn‚Äôt have a validator.&lt;/p&gt;

&lt;p&gt;If we ever want to change our business logic to allow a user to register without an email address, we would now have to make not only one but two parameters optional, since it would not make sense to have a non-optional validator for an optional value:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; User {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; emailAddress: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?

    &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;?(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, emailAddress: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, validator: &lt;span class=&quot;type&quot;&gt;EmailValidator&lt;/span&gt;?) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would give us quite a weird interface where we could pass an email address without a validator:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: &lt;span class=&quot;string&quot;&gt;&quot;dohn.joe@somecompany.com&quot;&lt;/span&gt;, validator: &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A cleaner way to do this is to put the validation where it belongs, which is with the email address rather with the user. We‚Äôll create an &lt;code class=&quot;highlighter-rouge&quot;&gt;EmailAddress&lt;/code&gt; struct containing both the actual &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; value for the address, and the validation logic. If we also add a failable initializer just as we did with &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;, we make sure we only get an object instance to work with if our precondtions are met.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; EmailAddress {
    &lt;span class=&quot;comment&quot;&gt;//A&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;allows&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;retrieve,&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;but&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;change,&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;outside&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;struct&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; (set)&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;?(addressToValidate address: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; isValid(address) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;
        }

        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;value&lt;/span&gt; = address
    }

    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; isValid(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; string: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; {
        ...
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; valueOfValidation
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; will then hold a reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;EmailAddress&lt;/code&gt;:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; User {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; emailAddress: &lt;span class=&quot;type&quot;&gt;EmailAddress&lt;/span&gt;

        &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;?(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, emailAddress: &lt;span class=&quot;type&quot;&gt;EmailAddress&lt;/span&gt;) {
            &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;name&lt;/span&gt; = name
            &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;emailAddress&lt;/span&gt; = emailAddress
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a lot cleaner api where the user does not have to bother with email validation, and we as coders don‚Äôt have to bother with non-natural sounding structs named stuff like Validator.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; validAddress = &lt;span class=&quot;type&quot;&gt;EmailAddress&lt;/span&gt;(addressToValidate: &lt;span class=&quot;string&quot;&gt;&quot;dohn.joe@somecompany.com&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;call&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Not&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;valid&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;address!&quot;&lt;/span&gt;)
}

&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: validAddress) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we‚Äôre later adding more data types to &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; that also needs validation, we could follow the same structure. If we‚Äôre adding several types we might want to create a protocol:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;protocol&lt;/span&gt; Validatable {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; isValid(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; string: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;
}

&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; EmailAdress: &lt;span class=&quot;type&quot;&gt;Validatable&lt;/span&gt; {...}

&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; CreditCard: &lt;span class=&quot;type&quot;&gt;Validatable&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; (set)&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;?(numberToValidate number: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;value&lt;/span&gt; = number

        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; isValid(number) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;
        }
    }

    &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; isValid(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; string: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; {
       ...
       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; valueOfValidation
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We‚Äôll add an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditCard&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; and now we can create user objects like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; validAddress = &lt;span class=&quot;type&quot;&gt;EmailAddress&lt;/span&gt;(addressToValidate: &lt;span class=&quot;string&quot;&gt;&quot;dohn.joe@somecompany.com&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;call&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Not&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;valid&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;address!&quot;&lt;/span&gt;)
}

&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; validCreditCard = &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;(numberToValidate: &lt;span class=&quot;string&quot;&gt;&quot;123456&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;call&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Not&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;valid&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;credit&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;card&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;number!&quot;&lt;/span&gt;)
}

&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user = &lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Dohn&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Joe&quot;&lt;/span&gt;, emailAddress: validAddress, creditCard: validCreditCard) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That‚Äôs all I had for this time. Hopefully you found something to your liking, and if not, that your disapproval of my coding style at least gave you some new fresh ideas on how to not do things :) I would love some feedback from anyone reading, so I‚Äôll make sure to get comments to work ASAP. Thank you for reading!&lt;/p&gt;</content><author><name></name></author><summary type="html">Syntax highlighting powered by Splash</summary></entry><entry><title type="html">Using enums to create flexible data models</title><link href="/2018/08/15/using-enums-to-create-flexible-data-models.html" rel="alternate" type="text/html" title="Using enums to create flexible data models" /><published>2018-08-15T22:32:38+02:00</published><updated>2018-08-15T22:32:38+02:00</updated><id>/2018/08/15/using-enums-to-create-flexible-data-models</id><content type="html" xml:base="/2018/08/15/using-enums-to-create-flexible-data-models.html">&lt;h6 id=&quot;syntax-highlighting-powered-by-splash&quot;&gt;Syntax highlighting powered by &lt;a href=&quot;https://github.com/JohnSundell/Splash&quot;&gt;Splash&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;In this post we‚Äôre going to look at how enums can be used as alternatives to structs and classes for creating data models. In Swift, enum cases can have so called associated values of any type, which is basically the same thing as properties in structs/classes. This make them quite flexible, as each case can store values that are relevant only to itself, yet they are all part of the same enum type.&lt;/p&gt;

&lt;p&gt;Enough chit-chat, let‚Äôs write some code! Let‚Äôs say we‚Äôre making an app for a restaurant, with a menu made up of different categories of food. We might create a simple struct like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This restaurant wants it‚Äôs food to be grouped by either of the categories meat, fish or dessert, so we‚Äôll create an enum within our struct and add a case for each category.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; category: &lt;span class=&quot;type&quot;&gt;Category&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Category {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; meat
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; fish
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; dessert
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now create different types of dishes like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; cheeseburger = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Cheeseburger&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, category: .&lt;span class=&quot;dotAccess&quot;&gt;meat&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bananaSplit = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Banana&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Split&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, category: .&lt;span class=&quot;dotAccess&quot;&gt;dessert&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a bit of coding, we realise we need to add beverages to the menu. Since drinks also have names and prices it seems reasonable to group these with the other menu items:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; category: &lt;span class=&quot;type&quot;&gt;Category&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Category {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; meat
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; fish
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; dessert
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; beverage
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this particular restaurant, all drinks come in sizes big or small, so we‚Äôll want a way to store that data as well. One way to do this would be to add a Size enum to our MenuItem struct, and then add a size property to hold this value. Since all edible menu items come in one size only it wouldn‚Äôt make sense for them to have a size value, so that property would need to be optional:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; category: &lt;span class=&quot;type&quot;&gt;Category&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; size: &lt;span class=&quot;type&quot;&gt;Size&lt;/span&gt;?

    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Category {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; meat
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; fish
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; dessert
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; beverage
    }

    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Size {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; big
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; small
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could now create instances of MenuItem like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bigMojito = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Mojito&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, category: .&lt;span class=&quot;dotAccess&quot;&gt;beverage&lt;/span&gt;, size: .&lt;span class=&quot;dotAccess&quot;&gt;big&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bolognese = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Spaghetti&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Bolognese&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, category: .&lt;span class=&quot;dotAccess&quot;&gt;meat&lt;/span&gt;, size: &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way of doing things is not very clean though, since the MenuItem struct is cluttered with a property that for most items is irrelevant and will be set to nil. Passing nil to the constructor doesn‚Äôt look very nice, and for someone not familiar with the code it might not be obvious which kind of item is supposed to get a non-nil value and which one doesn‚Äôt (big/small cheeseburger?).&lt;/p&gt;

&lt;p&gt;Instead of passing nil around, we could for example add an init method with the size parameter given a default value of nil, but even so our struct would contain a property it would not need for the most part.&lt;/p&gt;

&lt;p&gt;This is were things could be solved quite nicely by using an enum. As mentioned earlier, enum cases can store associated values of all kinds which make them just as fit for structuring data. Let‚Äôs rethink our menu a bit and replace the MenuItem struct with an enum. We‚Äôll start by just adding the non-liquid categories to our enum:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; meat(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; fish(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; dessert(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameters (name, price) are the associated values, and these are passed like any function arguments when creating an instance of the enum case. For example, we would now create our cheeseburger object like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; cheeseburger = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;meat&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Cheeseburger&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The names, types and amount of associated values for each case are completely detached from those of the other cases. This will be clear as we‚Äôll now add our beverage case to the MenuItem enum. Since we still want our drinks to have different sizes, we‚Äôll also add the Size enum as a member of MenuItem.&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; meat(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; fish(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; dessert(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; beverage(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, size: &lt;span class=&quot;type&quot;&gt;Size&lt;/span&gt;)

    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Size {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; big
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; small
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we now have drink case with a unique size parameter. Instead of having to bother with passing nil values for other items, we have a nice set of categories which are all of the same type (MenuItem), but can be easily extendable. We could now create items like this:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; seaBass = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;fish&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Grilled&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Sea&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Bass&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; frozenMargarita = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;drink&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Frozen&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Margarita&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, size: .&lt;span class=&quot;dotAccess&quot;&gt;big&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What‚Äôs really good about this technique is it‚Äôs flexibility - we can easily add or remove properties from any case without affecting the others. For example, sometime down the road we might decide that our app users should be able to choose how their meat will be prepared (it‚Äôs doneness - rare, medium etc.). We might also decide that all desserts should be free of charge, and thus won‚Äôt need a price property. This could easily be changed in our enum without bothering with optionals:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; MenuItem {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; meat(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, doneness: &lt;span class=&quot;type&quot;&gt;Doneness&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; fish(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; dessert(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; drink(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, size: &lt;span class=&quot;type&quot;&gt;Size&lt;/span&gt;)

    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Doneness {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; rare
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; medium
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; wellDone
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; steak = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;meat&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Steak&quot;&lt;/span&gt;, price: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, doneness: .&lt;span class=&quot;dotAccess&quot;&gt;rare&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; freeDessert = &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt;.&lt;span class=&quot;call&quot;&gt;dessert&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Creme&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Brulee&quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just as struct and classes, enums in Swift can also contain logic in the form of methods and computed properties. Why not serve drinks at half the price on Sundays:&lt;/p&gt;

&lt;pre class=&quot;splash&quot;&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MenuItem&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; price: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; .&lt;span class=&quot;dotAccess&quot;&gt;beverage&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt;, price, &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt;):
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;todayIsSunday&lt;/span&gt; ? price / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; : price
        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; price
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, enums can serve as a great alternative to structs and classes. Whenever you find yourself creating a struct containing an enum that declares different states defining it, chances are good you could refactor your struct to into being an actual enum.&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;</content><author><name></name></author><summary type="html">Syntax highlighting powered by Splash</summary></entry></feed>