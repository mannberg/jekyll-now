<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Not quite UI tests | Mannberg on Swift</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Not quite UI tests" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Syntax highlighting powered by Splash" />
<meta property="og:description" content="Syntax highlighting powered by Splash" />
<link rel="canonical" href="/2019/03/05/not-quite-ui-tests.html" />
<meta property="og:url" content="/2019/03/05/not-quite-ui-tests.html" />
<meta property="og:site_name" content="Mannberg on Swift" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-05T20:40:00+01:00" />
<script type="application/ld+json">
{"description":"Syntax highlighting powered by Splash","@type":"BlogPosting","url":"/2019/03/05/not-quite-ui-tests.html","headline":"Not quite UI tests","dateModified":"2019-03-05T20:40:00+01:00","datePublished":"2019-03-05T20:40:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/03/05/not-quite-ui-tests.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Mannberg on Swift" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Mannberg on Swift</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Not quite UI tests</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-05T20:40:00+01:00" itemprop="datePublished">Mar 5, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h6 id="syntax-highlighting-powered-by-splash">Syntax highlighting powered by <a href="https://github.com/JohnSundell/Splash">Splash</a></h6>

<h3 id="my-issue-with-ui-tests">My issue with UI tests</h3>

<p>So, I kind of have a problem with UI tests. I’ve tried them, but did not particularly like them. Actually, I really don’t like that I don’t like them, since I think the problem they are aiming to solve is extremely important. Testing how your system acts as a whole, rather than just testing it’s parts in isolation, is a brilliant idea. The problem I have is that I find UI tests in their current shape to be badly cut out for solving such an important problem.</p>

<p>My issue with UI tests basically boils down to two points:</p>

<ol>
  <li><strong>They’re slow.</strong></li>
</ol>

<p>UI tests are slow since they consist of actual interactions with your UI. Even though automated tapping of buttons can be pretty darned quick, you still need to wait for all those pretty view controller transitions, animations and possibly slow network requests. Also, since UI tests run in an actual instance of your app, you can’t just fire up any view controller and test it in isolation. This means that if you have a view controller that’s eleven button taps away from your user, it’s going to be eleven button taps (and who knows what else) away at the beginning of your test session.</p>

<ol>
  <li><strong>They’re black box tests.</strong></li>
</ol>

<p>When we use UI tests as opposed to unit tests, we give up on all the control we have over our system. We’re constrained by dependecies such as the backend and local databases, which we can mock to our heart’s content while we’re doing unit tests. One thing that’s often highlighted about UI tests is the fact that they’re testing a non-altered app session, free from possibly incorrect developer assumptions and test code bugs. This is definitively something worth highlighting, but I think it’s also worth highlighting that since they have all these dependencies that can’t be controlled, the app session they test tends to often become very restricted and not very representative of what the end user would experience anyway.</p>

<h3 id="something-in-between">Something in between</h3>

<p>What I would like us to try out in this post, is to come as close as possible to UI tests while still being able to tweak our code just as when we’re doing unit tests. To achieve this we’re going to use logic-free view controllers together with view models set up with data bindings. What I mean by logic-free is that the only thing our view controller is going to care about is sending it’s current state to the view model, receive a new state from said view model, and render itself accordingly.</p>

<p>For sake of simplicity, we’re not going to use <code class="highlighter-rouge">RxSwift</code> or any other 3rd party library for our bindings, but rather just the tools that are provided by Swift out of the box. However, there shouldn’t be any problem applying the same techniques using <code class="highlighter-rouge">Rx</code>, <code class="highlighter-rouge">Bond</code> or any other great framework out there.</p>

<p>The app we’re going to build to try these techniques is a very simple one: a login page with two fields (email and password), a login button with two different states (enabled/disabled), a loading indicator and a small label which will tell what, if anything, went wrong when trying to log in.</p>

<h3 id="inputs--outputs">Inputs &amp; outputs</h3>

<p>Starting off by setting up our view model, I’m gonna straight off borrow a concept from the awesome, open-sourced <a href="https://github.com/kickstarter/ios-oss">Kickstarter</a> app, where view models are defined as containing <code class="highlighter-rouge">inputs</code> and <code class="highlighter-rouge">outputs</code>, represented by two different protocols. In this case, we’re going to call them <code class="highlighter-rouge">LoginViewModelInputs</code> and <code class="highlighter-rouge">LoginViewModelOutputs</code>. <code class="highlighter-rouge">Inputs</code> is going to hold functions that will be triggered by events: in this example we’re going to deal only with events that are fired whenever the user interacts with the app (text input, tapping buttons), but it could’ve also been system events such as the view being loaded or the app going into background mode. <code class="highlighter-rouge">Outputs</code> will contain methods that the view controller listens to in order to re-render itself when the view model changes it’s state.</p>

<pre class="splash"><code><span class="keyword">protocol</span> LoginViewModelInputs {
    <span class="keyword">func</span> didPressLoginButton()
    <span class="keyword">func</span> emailDidChange(<span class="keyword">_</span> sender: <span class="type">UITextField</span>)
    <span class="keyword">func</span> passwordDidChange(<span class="keyword">_</span> sender: <span class="type">UITextField</span>)
}

<span class="keyword">protocol</span> LoginViewModelOutputs {
    <span class="keyword">var</span> userInputIsValid: ((<span class="type">Bool</span>) -&gt; <span class="type">Void</span>)? { <span class="keyword">get</span> <span class="keyword">set</span> }
    <span class="keyword">var</span> changedLoadingState: ((<span class="type">LoginViewModel</span>.<span class="type">State</span>) -&gt; <span class="type">Void</span>)? { <span class="keyword">get</span> <span class="keyword">set</span> }
}

<span class="keyword">class</span> LoginViewModel: <span class="type">LoginViewModelInputs</span>, <span class="call">LoginViewModelOutputs</span> {
    ...
    <span class="keyword">lazy</span> <span class="keyword">var</span> inputs: <span class="type">LoginViewModelInputs</span> = { <span class="keyword">return</span> <span class="keyword">self</span> }()
    <span class="keyword">lazy</span> <span class="keyword">var</span> outputs: <span class="type">LoginViewModelOutputs</span> = { <span class="keyword">return</span> <span class="keyword">self</span> }()
    ...
    }
}
</code></pre>

<p>Next we’re setting up our view controller. We’ll define a <code class="highlighter-rouge">setupBindings</code> method where we pass all our user input along to the view model while also listening to it’s output to update our UI.</p>

<pre class="splash"><code><span class="keyword">class</span> LoginViewController: <span class="type">UIViewController</span> {
    <span class="keyword">let</span> viewModel = <span class="type">LoginViewModel</span>()
    
    <span class="keyword">lazy</span> <span class="keyword">var</span> emailField: <span class="type">UITextField</span> ...
    <span class="keyword">lazy</span> <span class="keyword">var</span> passwordField: <span class="type">UITextField</span> ...
    <span class="keyword">lazy</span> <span class="keyword">var</span> infoLabel: <span class="type">UILabel</span> ...
    <span class="keyword">lazy</span> <span class="keyword">var</span> indicator: <span class="type">UIActivityIndicatorView</span> ...
    <span class="keyword">lazy</span> <span class="keyword">var</span> loginButton: <span class="type">UIButton</span> ...
    
    <span class="keyword">private</span> <span class="keyword">func</span> setupBindings() {
        <span class="comment">//view</span> <span class="comment">model</span> <span class="comment">inputs</span>
        loginButton.<span class="call">addTarget</span>(viewModel, action: <span class="keyword">#selector</span>(viewModel.<span class="property">didPressLoginButton</span>), for: .<span class="dotAccess">touchUpInside</span>)
        emailField.<span class="call">addTarget</span>(viewModel, action: <span class="keyword">#selector</span>(viewModel.<span class="call">emailDidChange</span>(<span class="keyword">_</span>:)), for: .<span class="dotAccess">editingChanged</span>)
        passwordField.<span class="call">addTarget</span>(viewModel, action: <span class="keyword">#selector</span>(viewModel.<span class="call">passwordDidChange</span>(<span class="keyword">_</span>:)), for: .<span class="dotAccess">editingChanged</span>)
        
        <span class="comment">//view</span> <span class="comment">model</span> <span class="comment">outputs</span>
        viewModel.<span class="property">outputs</span>.<span class="property">userInputIsValid</span> = { [unowned <span class="keyword">self</span>] isValid <span class="keyword">in</span>
            <span class="keyword">self</span>.<span class="property">loginButton</span>.<span class="property">isEnabled</span> = isValid
            <span class="keyword">self</span>.<span class="property">loginButton</span>.<span class="property">backgroundColor</span> = isValid ? .<span class="dotAccess">green</span> : .<span class="dotAccess">gray</span>
        }
        
        viewModel.<span class="property">outputs</span>.<span class="property">changedLoadingState</span> = { [unowned <span class="keyword">self</span>] state <span class="keyword">in</span>
            <span class="keyword">switch</span> state {
            <span class="keyword">case</span> .<span class="dotAccess">loading</span>:
                <span class="keyword">self</span>.<span class="property">indicator</span>.<span class="call">startAnimating</span>()
            <span class="keyword">case</span> .<span class="dotAccess">doneLoading</span>(<span class="keyword">_</span>):
                <span class="keyword">self</span>.<span class="property">indicator</span>.<span class="call">stopAnimating</span>()
                <span class="keyword">self</span>.<span class="property">infoLabel</span>.<span class="property">isHidden</span> = <span class="keyword">true</span>
            <span class="keyword">case</span> .<span class="dotAccess">failedLoading</span>(<span class="keyword">let</span> error) <span class="keyword">where</span> error == .<span class="dotAccess">invalidCredentials</span>:
                <span class="keyword">self</span>.<span class="property">indicator</span>.<span class="call">stopAnimating</span>()
                <span class="keyword">self</span>.<span class="property">infoLabel</span>.<span class="property">isHidden</span> = <span class="keyword">false</span>
                <span class="keyword">self</span>.<span class="property">infoLabel</span>.<span class="property">text</span> = <span class="string">"Invalid</span> <span class="string">credentials"</span>
                <span class="keyword">self</span>.<span class="property">infoLabel</span>.<span class="call">sizeToFit</span>()
            <span class="keyword">default</span>:
                ...
            }
        }
    }
    
    <span class="keyword">override</span> <span class="keyword">func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">setupBindings</span>()
    }
}
</code></pre>

<p>Then we’ll define some very simple business logic in our view model. User input is being constantly evaluated and considered valid enough for sending to our backend when the email field contains an <code class="highlighter-rouge">@</code> and the password is four or more characters long. The observing view controller is continuously updated about what state the view model is in, and will toggle the enabled state of it’s login button as the user’s input changes. The login button’s tap event triggers a login request, and the view model notifies the view controller as soon as it’s loading state changes.</p>

<pre class="splash"><code><span class="keyword">class</span> LoginViewModel: <span class="type">LoginViewModelInputs</span>, <span class="call">LoginViewModelOutputs</span> {
    ...

    <span class="keyword">@objc</span> <span class="keyword">func</span> emailDidChange(<span class="keyword">_</span> sender: <span class="type">UITextField</span>) {
        email = sender.<span class="property">text</span> ?? <span class="string">""</span>
    }
    
    <span class="keyword">@objc</span> <span class="keyword">func</span> passwordDidChange(<span class="keyword">_</span> sender: <span class="type">UITextField</span>) {
        password = sender.<span class="property">text</span> ?? <span class="string">""</span>
    }
    
    <span class="keyword">@objc</span> <span class="keyword">func</span> didPressLoginButton() {
        changedLoadingState?(.loading)
        api.<span class="call">login</span>() { result <span class="keyword">in</span>
            <span class="keyword">switch</span> result {
            <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> user):
                changedLoadingState?(.<span class="call">doneLoading</span>(user))
            <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
                changedLoadingState?(.<span class="call">failedLoading</span>(error))
            }
        }
    }
    
    <span class="keyword">private</span> <span class="keyword">var</span> email = <span class="string">""</span> {
        <span class="keyword">didSet</span> { userInputIsValid?(<span class="call">inputIsValid</span>()) }
    }
    
    <span class="keyword">private</span> <span class="keyword">var</span> password = <span class="string">""</span> {
        <span class="keyword">didSet</span> { userInputIsValid?(<span class="call">inputIsValid</span>()) }
    }

    <span class="keyword">private</span> <span class="keyword">func</span> inputIsValid() -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> <span class="call">emailIsValid</span>(email) &amp;&amp; <span class="call">passwordIsValid</span>(password)
    }
    
    <span class="keyword">private</span> <span class="keyword">func</span> emailIsValid(<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> text.<span class="call">contains</span>(<span class="string">"@"</span>)
    }
    
    <span class="keyword">private</span> <span class="keyword">func</span> passwordIsValid(<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> text.<span class="property">count</span> &gt;= <span class="number">4</span>
    }
}
</code></pre>

<p>Finally, before we start writing tests, we’ll add a small extension to <code class="highlighter-rouge">UITextField</code> which we’ll use for updating our fields programmatically.</p>

<pre class="splash"><code><span class="keyword">extension</span> <span class="type">UITextField</span> {
    <span class="keyword">func</span> update(<span class="keyword">_</span> text: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">text</span> = text
        <span class="keyword">self</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">editingChanged</span>)
    }
}
</code></pre>

<h3 id="testing-testing">Testing, testing…</h3>

<p>So, we’ve set up out controller and model, and now it’s time to take it for a spin. We’ll start by initalizing our view controller and run it’s <code class="highlighter-rouge">viewDidLoad</code> method, where we ran the <code class="highlighter-rouge">setupBindnings</code> method. By running <code class="highlighter-rouge">viewDidLoad</code> rather than <code class="highlighter-rouge">setupBindnings</code> directly, we are actually testing that this method will be triggered by the system when running the app.</p>

<pre class="splash"><code><span class="keyword">let</span> vc = <span class="type">LoginViewController</span>()
vc.<span class="call">viewDidLoad</span>()
</code></pre>

<p>Alright, so we have our vc set up, and now we want to start by testing it’s default state. Since no input has yet been given, we want to verify that the info label is not showing and that the login button is disabled.</p>

<pre class="splash"><code><span class="call">assert</span>(vc.<span class="property">infoLabel</span>.<span class="property">isHidden</span>)
assert(!vc.<span class="property">loginButton</span>.<span class="property">isEnabled</span>)
</code></pre>

<p>Ok, our assertions passed. Next up, we’re going to enter a valid email and password and verify that this enables the login button. Note how we’re testing both our email and password validation logic as well as our UI’s response, all in a few lines.</p>

<pre class="splash"><code>vc.<span class="property">emailField</span>.<span class="call">update</span>(<span class="string">"joe@south.com"</span>)
vc.<span class="property">passwordField</span>.<span class="call">update</span>(<span class="string">"abca"</span>)
<span class="call">assert</span>(vc.<span class="property">loginButton</span>.<span class="property">isEnabled</span>)
<span class="call">assert</span>(vc.<span class="property">loginButton</span>.<span class="property">backgroundColor</span> == .<span class="dotAccess">green</span>)
</code></pre>

<p>Just to be sure, let’s verify that our loginButton is again disabled after changing the email adress being something invalid (not containing an @)</p>

<pre class="splash"><code>vc.<span class="property">emailField</span>.<span class="call">update</span>(<span class="string">"joe.south.com"</span>)
assert(!vc.<span class="property">loginButton</span>.<span class="property">isEnabled</span>)
<span class="call">assert</span>(vc.<span class="property">loginButton</span>.<span class="property">backgroundColor</span> == .<span class="dotAccess">gray</span>)
</code></pre>

<p>So far so good, but we haven’t really done anything yet that we could not do with UI tests. In a <a href="https://mannberg.github.io/2018/12/19/mocking.html">previous article</a> I looked at how you can easily mock methods rather than entire objects, and we’re going to use that same approach here to simulate the user trying to log in with invalid credentials. Just like when we’re doing “regular” unit testing, we can have complete control over our dependencies, which means we can easily mock server responses to generate all kinds of different UI states.</p>

<pre class="splash"><code>vc.<span class="property">viewModel</span>.<span class="property">api</span>.<span class="property">login</span> = { result <span class="keyword">in</span>
    result(.<span class="dotAccess">failure</span>(.<span class="dotAccess">invalidCredentials</span>))
}
</code></pre>

<p>Now, when “tapping” our button, we should immediately get an error, showing our infoLabel with the expected error message.</p>

<pre class="splash"><code>vc.<span class="property">emailField</span>.<span class="call">update</span>(<span class="string">"joe@south.com"</span>)
vc.<span class="property">viewModel</span>.<span class="call">didPressButton</span>()
assert(!vc.<span class="property">infoLabel</span>.<span class="property">isHidden</span>)
<span class="call">assert</span>(vc.<span class="property">infoLabel</span>.<span class="property">text</span> == <span class="string">"Invalid</span> <span class="string">credentials"</span>)
</code></pre>

<p>While we’re at it, we might want to test our app’s behavior if our given credentials were instead valid.</p>

<pre class="splash"><code><span class="comment">//we'll</span> <span class="comment">change</span> <span class="comment">our</span> <span class="comment">mocked</span> <span class="comment">response</span> <span class="comment">to</span> <span class="comment">be</span> <span class="comment">successful...</span>
vc.<span class="property">viewModel</span>.<span class="property">api</span>.<span class="property">login</span> = { result <span class="keyword">in</span>
    <span class="keyword">let</span> user = <span class="type">User</span>()
    <span class="call">result</span>(.<span class="dotAccess">success</span>(user))
}

<span class="comment">//then</span> <span class="comment">try</span> <span class="comment">to</span> <span class="comment">login,</span> <span class="comment">which</span> <span class="comment">should</span> <span class="comment">make</span> <span class="comment">our</span> <span class="comment">infoLabel</span> <span class="comment">disappear</span>
vc.<span class="property">viewModel</span>.<span class="call">didPressButton</span>()
<span class="call">assert</span>(vc.<span class="property">infoLabel</span>.<span class="property">isHidden</span>)
</code></pre>

<p>Our tests passed! Although this is a rather trivial example, I think it’s not hard to see how this could easily be extended. If our app had a profile page for example, we should be able to mock a logged in user and verify that all the correct information was displayed. If we then wanted to change any field on our user, we should easily be able to do so by mocking some backend response and then again verify that our UI correctly displays the new information. Should we want to test that the UI correctly handles this same request failing, we should also be able to do so with very little extra ceremony.</p>

<h3 id="conclusion">Conclusion</h3>

<p>We’ve seen how we could simulate user interaction and make this run as quickly as any suite of unit tests. We were able to do inline mocking of our backend, easily testing how our UI reacts to various weird states. One could say we’ve taken some powerful traits of unit tests (controlling dependencies, speed) and combined it with an equally powerful trait of UI tests (testing using interaction).</p>

<p>Testing business logic through the UI can be quite powerful. For example, we might write unit tests for an email validation method, but we might still forget to actually use that method in our app when when the user types in their value. By simulating input into a text field and observing the UI’s reaction to it, we test both the validation logic and that it’s actually used for text input. Of course, testing business logic only by observing the UI would result in a lot of boilerplate, so when we need some really thourough testing of our business logic, unit tests are probably the way to go.</p>

<p>One problem with this kind of testing is that we’re not only mocking our dependencies, but we’re kind of also mocking the actual app lifecycle. In our code example above, we manually called the <code class="highlighter-rouge">viewDidLoad</code> method of our view controller, which would’ve been called by the system in a regular app session. But we might just as well have forgotten to call this or any other system-triggered events, which could render our tests useless at best, and hiding bugs at worst. 
Similar problems could also arise if we were to write tests that simulated user interaction that would not be possible in the actual app.</p>

<p>So, the usual pros and cons. If you have thoughts on this and perhaps even experience of doing something similar in a project, I would really like to hear about it on <a href="https://twitter.com/andersmannberg">Twitter</a>.</p>

<p>Thank you so much for reading!</p>

  </div><a class="u-url" href="/2019/03/05/not-quite-ui-tests.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Mannberg on Swift</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mannberg on Swift</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/mannberg"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mannberg</span></a></li><li><a href="https://www.twitter.com/andersmannberg"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">andersmannberg</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
