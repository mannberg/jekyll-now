<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Avoid mocking by swapping method implementations | Mannberg on Swift</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Avoid mocking by swapping method implementations" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Syntax highlighting powered by Splash" />
<meta property="og:description" content="Syntax highlighting powered by Splash" />
<link rel="canonical" href="http://localhost:4000/2018/12/19/mocking.html" />
<meta property="og:url" content="http://localhost:4000/2018/12/19/mocking.html" />
<meta property="og:site_name" content="Mannberg on Swift" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-19T21:00:00+01:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2018/12/19/mocking.html","headline":"Avoid mocking by swapping method implementations","dateModified":"2018-12-19T21:00:00+01:00","datePublished":"2018-12-19T21:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/12/19/mocking.html"},"description":"Syntax highlighting powered by Splash","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Mannberg on Swift" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Mannberg on Swift</a>
    <p class="subtitle">Exploring functional programming, test-driven development and all that jazz!</p><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About this site</a><a class="page-link" href="/links/">Links</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Avoid mocking by swapping method implementations</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-12-19T21:00:00+01:00" itemprop="datePublished">Dec 19, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h6 id="syntax-highlighting-powered-by-splash">Syntax highlighting powered by <a href="https://github.com/JohnSundell/Splash">Splash</a></h6>

<p>Often when we want to test code that depends on external resources such as a backend or a local database, we need to mock those dependencies. Mocking usually consists of defining a protocol which our other objects depend on rather than depending on a concrete implementation, as well as creating at least two classes/structs that implement that protocol - one that‚Äôs used in our app, and at least one mock version used for testing.</p>

<p>This choice of path usually ends up in writing lots of boilerplate code, in addition to all the extra code we‚Äôre already writing for our tests. Few people would probably argue against testing as a good thing, but in the harsh reality of tight deadlines it‚Äôs no secret that test code is constantly in harm‚Äôs way. So, anything we can do to make writing tests less of a hassle, we should.</p>

<p>In this article we‚Äôre going to a explore a less object-oriented approach, in which we‚Äôll mock methods rather than entire objects.</p>

<h3 id="fetching-movies">Fetching movies</h3>

<p>Let‚Äôs say we have a simple app that fetches a bunch of movies from an api and presents them in a <code class="highlighter-rouge">MovieListViewController</code>. To do this, we need some sort of <code class="highlighter-rouge">APIService</code> that makes network requests to fetch that data.</p>

<p>Since we want to write tests for objects depending on this class, we want to be able to mock it, so we start by defining a protocol as follows</p>

<pre class="splash"><code><span class="keyword">protocol</span> NetworkFetching {
    <span class="keyword">func</span> fetchMovies(result: (<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>)
}
</code></pre>

<p>Then we create the concrete implementation that will be used used in our app‚Ä¶</p>

<pre class="splash"><code><span class="keyword">struct</span> APIService: <span class="type">NetworkFetching</span> {
    <span class="keyword">func</span> fetchMovies(result: (<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>) {
        <span class="comment">//Perform</span> <span class="comment">network</span> <span class="comment">request</span> <span class="comment">to</span> <span class="comment">fetch</span> <span class="comment">movies</span>
        ...
    }
}
</code></pre>

<p>‚Ä¶ and then our mocked class.</p>

<pre class="splash"><code><span class="keyword">struct</span> MockAPIService: <span class="type">NetworkFetching</span> {
    <span class="keyword">func</span> fetchMovies(result: (<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>) {
        <span class="comment">//Return</span> <span class="comment">a</span> <span class="comment">hard-coded</span> <span class="comment">result</span>
        ...
    }
}
</code></pre>

<p>We‚Äôve designed our app so that <code class="highlighter-rouge">MovieListViewController</code> has a <code class="highlighter-rouge">MovieListViewModel</code>, which in turn has a reference to an <code class="highlighter-rouge">APIService</code> instance implementing the <code class="highlighter-rouge">NetworkFetching</code> protocol. The view model also has a <code class="highlighter-rouge">state</code> property which our view controller binds to in order to update it‚Äôs views. We might, for example, want to show/hide a loading indicator as we‚Äôre waiting for/presenting data, and show error messages if the request should fail.</p>

<pre class="splash"><code><span class="keyword">class</span> MovieListViewModel {
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> apiService = factory.<span class="call">makeAPIService</span>()
    ...
    
    <span class="keyword">func</span> fetchMovies() {
        state = .<span class="dotAccess">loading</span>
        apiService.<span class="call">fetchMovies</span> { result <span class="keyword">in</span>
            <span class="keyword">switch</span> result {
            <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> movies):
                <span class="keyword">self</span>.<span class="property">movies</span> = movies
                state = .<span class="dotAccess">doneLoading</span>
            <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
                state = .<span class="dotAccess">failedLoading</span>
            }
        }
    }
}
</code></pre>

<p>We now decide we want a unit test that ensures our view model always correctly updates it‚Äôs state property to <code class="highlighter-rouge">.doneLoading</code> when we get a successful reponse from our backend. In other words, we want to test our view model‚Äôs <code class="highlighter-rouge">fetchMovies</code> method but mock out the actual network request in our <code class="highlighter-rouge">APIService</code>. We also want to make sure our view model‚Äôs <code class="highlighter-rouge">movies</code> property is updated as expected. So we‚Äôll implement the mocked method to just return hard-coded data</p>

<pre class="splash"><code><span class="keyword">struct</span> MockAPIService: <span class="type">NetworkFetching</span> {
    <span class="keyword">func</span> fetchMovies(handler: (<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>) {
        <span class="keyword">let</span> movies = [
            <span class="type">Movie</span>(title: <span class="string">"Forrest</span> <span class="string">Gump"</span>, rating: <span class="number">5</span>),
        ]

        <span class="call">handler</span>(.<span class="dotAccess">success</span>(movies))   
    }
}
</code></pre>

<p>Then, we‚Äôll write our test</p>

<pre class="splash"><code><span class="keyword">func</span> testFetchMoviesSuccessShouldSetStateToDoneLoading {
    <span class="keyword">let</span> viewModel = <span class="type">MovieListViewModel</span>(factory: <span class="type">MockFactory</span>())

    viewModel.<span class="call">fetchMovies</span>()
    <span class="type">XCTAssertTrue</span>(viewModel.<span class="property">state</span> == .<span class="dotAccess">doneLoading</span>)
    <span class="type">XCTAssertTrue</span>(viewModel.<span class="property">movies</span>.<span class="property">count</span> == <span class="number">1</span>)
}
</code></pre>

<p>One thing to note is that we‚Äôre using a Factory to set up our objects and inject that Factory rather than making our objects responsible for injecting and creating other objects. This pattern is really great for isolating dependencies, but by using this approach together with mocking, we probably also want to create a MockFactory that implements a <code class="highlighter-rouge">Factory</code> protocol. In other words, even more boilerplate code!</p>

<h3 id="just-in-time-mocking">‚ÄúJust-in-time‚Äù mocking</h3>

<p>Perhaps it‚Äôs time we stop and think about what part of all that extra code that was actually needed for us in order to test our code. The <code class="highlighter-rouge">MockAPIService</code> class has no real value in itself rather than being a wrapper for the mocked <code class="highlighter-rouge">fetchMovies</code> method whose output - a result type containing a hard-coded list of movies - we were interested in. And although the protocol-oriented nature of Swift is really great, it‚Äôs not unusual that we end up with protocols that are there just for the sake of mocking.</p>

<p>Perhaps we could try a more functional approach! So let‚Äôs redo this a bit. Firstly, we‚Äôll scrap our <code class="highlighter-rouge">MockAPIService</code> as well as the <code class="highlighter-rouge">NetworkFetching</code> protocol. Also, away with the unnecessary <code class="highlighter-rouge">MockFactory</code> implementation.</p>

<p>We‚Äôll then rewrite our <code class="highlighter-rouge">ApiService</code> from this‚Ä¶</p>
<pre class="splash"><code><span class="keyword">struct</span> APIService: <span class="type">NetworkFetching</span> {
    <span class="keyword">func</span> fetchMovies(result: (<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>) {
        ...
    }
}
</code></pre>

<p>‚Ä¶ to this</p>

<pre class="splash"><code><span class="keyword">struct</span> APIService {
    <span class="keyword">var</span> fetchMovies: ((<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span> = { handler <span class="keyword">in</span>
        ...
    }
}
</code></pre>

<p>Our <code class="highlighter-rouge">fetchMovies</code> method still has the exact same function signature as it did before‚Ä¶</p>

<pre class="splash"><code>((<span class="type">Result</span>&lt;<span class="type">Movie</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>
</code></pre>

<p>‚Ä¶ but we redefined it using closure syntax and stored it in a variable, the latter being key since mutability is just what we‚Äôre after here.</p>

<p>Now that we‚Äôve scrapped 2 protocols and 2 mocked classes, we should try to rewrite our unit test.</p>

<pre class="splash"><code><span class="keyword">func</span> testFetchMoviesSuccessShouldSetStateToDoneLoading {
    <span class="keyword">var</span> viewModel = <span class="type">MovieListViewModel</span>(factory: <span class="type">Factory</span>())

    viewModel.<span class="property">apiService</span>.<span class="property">fetchMovies</span> = { handler <span class="keyword">in</span>
        <span class="keyword">let</span> movies = [
            <span class="type">Movie</span>(title: <span class="string">"Forrest</span> <span class="string">Gump"</span>, rating: <span class="number">5</span>),
        ]

        <span class="call">handler</span>(.<span class="dotAccess">success</span>(movies))   
    }

    viewModel.<span class="call">fetchMovies</span>()
    <span class="type">XCTAssertTrue</span>(viewModel.<span class="property">state</span> == .<span class="dotAccess">doneLoading</span>)
    <span class="type">XCTAssertTrue</span>(viewModel.<span class="property">movies</span>.<span class="property">count</span> == <span class="number">1</span>)
}
</code></pre>

<p>Notice that by just swapping a method implementation, we could easily mock the state we needed to test our code. Since we removed the mock classes and also the protocols that were really just there for testing purposes, all our test-specific code is right now contained in our test target, right where it belongs!</p>

<p>One great thing about this approach is it‚Äôs flexibility. For example, we might want to mock several different types of network responses to test how our depending classes behave. This is hassle-free and involves no creation of additional mock objects</p>

<pre class="splash"><code><span class="keyword">func</span> testFetchMoviesErrorShouldSetStateToFailedLoading {
    ...
    viewModel.<span class="property">apiService</span>.<span class="property">fetchMovies</span> = { handler <span class="keyword">in</span>
        handler(.<span class="dotAccess">failure</span>(.<span class="dotAccess">timeout</span>))   
    }

    viewModel.<span class="call">fetchMovies</span>()
    <span class="type">XCTAssertTrue</span>(viewModel.<span class="property">state</span> == .<span class="dotAccess">failedLoading</span>)
}
</code></pre>

<h3 id="drawbacks">Drawbacks</h3>

<p>Ok, so here come the boring, mildly shocking, news: This solution is <em>not</em> perfect üò≤. Let‚Äôs look at some of the drawbacks.</p>

<ul>
  <li>Named parameters don‚Äôt work with closures</li>
</ul>

<p>Named parameters is, according to me, one of the things that makes Swift really stand out from many other languages. Unfortunately, defining our methods as mutable closures, we have to give up on this great feature</p>

<pre class="splash"><code><span class="comment">//this</span>
<span class="keyword">func</span> <span class="keyword">set</span>(<span class="keyword">_</span> movie: <span class="type">Movie</span>, asFavorite favorite: <span class="type">Bool</span>) {...}

<span class="call">set</span>(someMovie, asFavorite: <span class="keyword">true</span>)

<span class="comment">//becomes</span> <span class="comment">this</span>
<span class="keyword">var</span> set: (<span class="type">Movie</span>, <span class="type">Bool</span>) = { movie, favorite <span class="keyword">in</span> ...}

<span class="call">set</span>(someMovie, true)
</code></pre>

<ul>
  <li>Mutability</li>
</ul>

<p>It might seem as a bit of an anti-pattern to have all this mutable state floating around in our application. Actually, as far as methods are concerned, the risk of an object accidentally replacing a method implementation with another one is probably not that big.</p>

<p>Making stored properties mutable for the sake of testing flexibility, however, seems far riskier and is probably something we should avoid doing. Using computed properties or immutable stored properties as much as possible should be the way forward here.</p>

<p>Thanks a bunch for reading! Please feel free to reach out on <a href="https://twitter.com/andersmannberg">Twitter</a> and share your thoughts on this and other Swifty topics!</p>


  </div><a class="u-url" href="/2018/12/19/mocking.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Mannberg on Swift</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mannberg on Swift</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/mannberg"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mannberg</span></a></li><li><a href="https://www.twitter.com/andersmannberg"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">andersmannberg</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
